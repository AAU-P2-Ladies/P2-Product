function prefMatrixCreator(students[])
    initialize matrix[students.length][students.length]
    row_loop : for i = 1 to students.length
        column_loop : for j = 1 to students.length
            if i == j
                matrix[i][j] = 1
            else if i < j
            matrix[i][j] = pref_check(students[i], students[j], students.length) 
                         + pref_check(students[j], students[i], students.length)
            //If both students have topics in their topics array, search if any are in common elements
            if students[i].topics[1] != NIL and students[j].topics[1] != NIL
                if commonElement(students[i].topics, students[j].topics) == false
                    matrix[i][j] += student.length
            else matrix[i][j] = matrix[j][i]
    return matrix
    
function indexStudents(students[])
    for i = 1 to students.length
        students[i].index = i
    return students
    
function findPrefSum(student1, student2, matrix)
    return matrix[student1.index][student2.index]

function prefCheck(student1, student2, student_number)
    i = linearSearch(student2, student1.prefs)
    if i > 0
        return i
    i = linearSearch(student2, student1.blocks)
    if i > 0
        return student_number
    else
        return floor(student_number/2)


        
//As input, this function accepts group sizes of at least 2
function prefGroups(students[], matrix, group_size)
    group_number = ceiling(students.length/group_size)
    //If the students cannot be evenly divided, there have to be a number of smaller groups
    if students.length mod group_size != 0
        smaller_groups = group_size - (students.length mod group_size)
    //small_group_size = ceiling(smaller_groups/group_number)
        while(smaller_groups > group_number)
            group_size -= floor(smaller_groups/group_number)
            smaller_groups = group_size - (students.length mod group_size)
    groups[group_number]
    pref_avg[group_number]
    //The first student in the first group, since order does not matter
    for i = 1 to group_number
        j = i
        while students[j].in_group == true
            j++
        groups[i].students[1] = students[j]
        students[j].in_group = true
        k = find_min(matrix[j])
        groups[i].students[2] = students[k]
        students[k].in_group = true
    for x = group_number+1 to students.size
        if students[x].in_group == true
            continue
        for i = 1 to group_number
            if groups[i].full == true
                continue
            pref_avg[i] = 0
            j = 1
            for j to group_size
                if groups[i].students[j] == NIL
                    j++
                    break
                pref_avg[i] += findPrefSum(students[x], groups[i].students[j].index, matrix)
            pref_avg[i] /= j-1
        i = find_min_space(pref_avg, groups)
        groups[i].students.append(students[x])
        if groups[i].students.length == group_size or (i > group_number - smaller_groups and groups[i].students.length == group_size - 1)
            groups[i].full = true
    return groups
    

function role_check(student1, student2)
    //If one "student" is an empty space, no overlap
    if student1 == NIL or student2 == NIL
        return 0
    sum = 0
    For(i in student1.roles)
        For j in(student2.roles)
            if student1.roles[i] == student2.roles[j]
                sum += 1
    return sum
