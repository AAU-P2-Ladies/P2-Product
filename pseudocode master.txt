//This helper function checks a group and returns the role diversity percentage
function check_role_diversity(students[])
    unique_roles[]
    total_roles
    for i = 1 to students.length
        for j = 1 to students[i].roles.length
            if students[i].roles[j] in unique_roles == false
                unique_roles.append(students[i].roles[j])
            total_roles++
    return unique_roles.size/total_roles

//This function takes an array of groups and returns an array containing only the groups that are below minimum diversity
function check_min_diversity(groups[], min_diversity)
    homogenous_groups[]
    for i = 1 to groups.length
        if check_role_diversity(groups[i]) < min_diversity
            homogenous_groups.append(groups[i])
    return homogenous_groups
        
//This boolean function takes a group and a minimum diversity.
//It returns true if only if the group has reached minimum diversity
function group_diversity_check(group, min_diversity)
    if(check_role_diversity(group.students)) < min_diversity
        return true
    else
        return false
        
//This function finds a students' preference average with the 
function group_pref_avg(student, group)
    pref_sum = 0
    for i = 1 to group.students.length
        pref_sum += pref_check(student, group.students[i])
    return pref_sum/group.students.length
    
function find_min_space(array, boolean)
    i = 1
    key = 0
    while key == 0
        if boolean[i] == true
            key = array[i]
        i++
    for i to array.length
        if groups[i] < key and boolean[i] == true
            key = array[i]
    return key

//This "small" helper function finds the best swap for an origin student and all the other potential groups
//It either returns the index of the student that should be swapped
//If no improving swaps can be made, return -1
function swap_check(origin, students[], groups[], min_diversity, matrix)
    origin_group = groups[origin.group_num]
    initialize pref_delta[students.length]
    initialize div_improvements[students.length]
    //Initialize some 2-element arrays.
    //The first element is for the origin group and the second element is for the new group.
    initialize diverse_old[2] = false
    initialize diverse_new[2] = false
    diverse_old[1] = group_diversity_check(origin_group, min_diversity)
    initialize pref_avg_old[2]
    initialize pref_avg_new[2]
    pref_avg_old[1] += group_pref_avg(origin, origin_group)
    //This loop goes through every group
    for i = 1 to groups.length
        diverse_old[2] = group_diversity_check(groups[i], min_diversity)
        //If this is the origin's group, no swaps need to be checked
        if origin_group == groups[i]
            continue
        //Now to through all students to check what a swap would do
        for j = 1 to groups[i].students.length
            target = groups[i].students[j]
            pref_avg_old[2] = group_pref_avg(target, groups[i])
            swap_students(origin, target)
            diverse_new[1] = group_diversity_check(groups[origin.group_num])
            diverse_new[2] = group_diversity_check(groups[i])
            //If the number of diverse groups is not decreased by the swap, calculate the preference delta
            diversity_delta = diverse_new[1] + diverse_new[2] - diverse_old[1] - diverse_old[2
            if diversity_delta > 0
                div_improvements[target.index] = true
            if diversity_delta >= 0
                //The preference delta is simply the difference in average preference for the two groups
                pref_avg_new[1] = group_pref_avg(target, origin_group)
                pref_avg_new[2] = group_pref_avg(origin, groups[i])
                pref_delta[target.index] = pref_avg_new[1] + pref_avg_new[2] - pref_avg_old[1] - pref_avg_old[2]
            else
                pref_delta[target.index] = 0
            swap_students(origin,target)
    //If no swaps can increase the number of diverse groups, simply return the best swap
    if indexOf(div_improvements, true) == 0
        best_swap = find_min(pref_delta)
        //If the best swap does not improve the pref satisfaction (ie. is not negative), return 0
        if pref_delta[best_swap] >= 0
            return 0
        else 
            return best_swap
    //If there exist swaps that increase the number of diverse groups, find the best of these swaps and return it
    else
        return = find_min_space(pref_delta, div_improvements)

//Swaps two students and also makes sure that their attached group number is still correct
function swap_students(student1, student2)
    swap(student1.group_num, student2.group_num)
    swap(student1, student2)

//This function takes an existing set of groups and tries to ensure minimum diversity.
//Furthermore, it swaps students in order to maximize preference satisfaction
function master_algorithm(students[], groups[], min_diversity, matrix)
    check_min_diversity(groups[], min_diversity)
    //If there exist groups that do not fulfill min diversity, start with those
    if homogenous_groups[1] != NIL
        //Call swap_check on each student in these groups
        for i = 1 to homogenous_groups.length
            for j = 1 to groups[i].students.length
                target = swap_check(groups[i].students[j], students, groups, min_diversity, matrix)
                //Only swap if there is a valid target
                if target > 0
                    swap(groups[i].students[j], students[target])
    swapped = true
    iterations = 0
    //Now loop through all the students, calling swap_check
    //Keep looping until not a single improving swap can be made
    //max iterations will be some variable that makes the program terminate in case it runs too long
    while(swapped == true && iterations <= max_iterations)
        swapped = false
        iterations++
        for i = 1 to groups.length
            for j = 1 to groups[i].students.length
                target = swap_check(groups[i].students[j], groups, min_diversity, matrix)
                if target > 0
                    swapped = true
                    swap(groups[i].students[j], target)
    return groups
